<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong Clone with Blocks</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            box-sizing: border-box;
        }
        body {
            background-color: #333;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            min-width: 100vw;
        }
        .canvas-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            background: #000;
            display: block;
            margin: 0 auto;
            box-sizing: border-box;
            /* Always fills the container, but keeps aspect ratio */
            width: 98vw;
            height: 85vh;
            max-width: 1200px;
            max-height: 900px;
            border: 2px solid #0095DD;
        }
        #startButton, #restartButton {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 20px;
            background-color: #0095DD;
            color: white;
            border: none;
            cursor: pointer;
            z-index: 5;
        }
        #startButton { top: 50%; }
        #gameOverScreen {
            display: none;
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(30, 41, 59, 0.95);
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 10;
        }
        #gameOverContent {
            text-align: center;
            color: #fff;
        }
        #restartButton {
            margin-top: 24px;
            position: static;
            transform: none;
        }
    </style>
</head>
<body>
    <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>
    </div>
    <button id="startButton">Start Game</button>
    <div id="gameOverScreen" class="canvas-container" style="display:none;">
        <div id="gameOverContent">
            <h1 style="font-size:2.4rem; margin-bottom:0.8rem;">Game Over!</h1>
            <div id="finalScore" style="font-size:1.5rem; margin-bottom:1.5rem;"></div>
            <button id="restartButton">Restart</button>
        </div>
    </div>
    <script>
    // --- Responsive Canvas Management ---
    const BASE_WIDTH = 800;
    const BASE_HEIGHT = 600;

    function resizeCanvas() {
        const canvas = document.getElementById('gameCanvas');
        // Get max available area while keeping aspect ratio
        const maxW = window.innerWidth * 0.98;
        const maxH = window.innerHeight * 0.85;
        let width = maxW, height = width * (BASE_HEIGHT / BASE_WIDTH);
        if (height > maxH) {
            height = maxH;
            width = height * (BASE_WIDTH / BASE_HEIGHT);
        }
        canvas.width = width;
        canvas.height = height;
    }

    // --- Game Classes ---
    class PlayerPaddle {
        constructor(game) {
            this.game = game;
            this.reset();
        }

        reset() {
            this.width = 100 * this.game.xScale;
            this.height = 15 * this.game.yScale;
            this.position = {
                x: this.game.width / 2 - this.width / 2,
                y: this.game.height - this.height - 10 * this.game.yScale
            };
            this.maxSpeed = 7 * this.game.xScale;
            this.speed = 0;
        }
        
        moveLeft() { this.speed = -this.maxSpeed; }
        moveRight() { this.speed = this.maxSpeed; }
        stop() { this.speed = 0; }
        
        update() {
            this.position.x += this.speed;
            if (this.position.x < 0) this.position.x = 0;
            if (this.position.x + this.width > this.game.width) {
                this.position.x = this.game.width - this.width;
            }
        }
        
        draw(ctx) {
            ctx.fillStyle = '#0095DD';
            ctx.fillRect(this.position.x, this.position.y, this.width, this.height);
        }
    }

    class Ball {
        constructor(game, paddle, blocks) {
            this.game = game;
            this.paddle = paddle;
            this.blocks = blocks;
            this.baseSize = 10;
            this.reset();
        }

        reset() {
            this.size = this.baseSize * this.game.xScale;
            this.position = { x: this.game.width / 2, y: this.game.height / 2 };
            // scale speeds so game feels similar at all sizes
            this.speed = { x: 4 * this.game.xScale, y: -4 * this.game.yScale };
        }

        draw(ctx) {
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(this.position.x, this.position.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }

        update() {
            this.position.x += this.speed.x;
            this.position.y += this.speed.y;

            // Wall collision (left/right)
            if (this.position.x - this.size < 0 || this.position.x + this.size > this.game.width) {
                this.speed.x = -this.speed.x;
            }

            // Wall collision (top)
            if (this.position.y - this.size < 0) {
                this.speed.y = -this.speed.y;
            }

            // Paddle collision
            if (
                this.position.y + this.size >= this.paddle.position.y &&
                this.position.x >= this.paddle.position.x &&
                this.position.x <= this.paddle.position.x + this.paddle.width &&
                this.position.y < this.paddle.position.y + this.paddle.height
            ) {
                this.speed.y = -Math.abs(this.speed.y);
                this.position.y = this.paddle.position.y - this.size;
            }

            // Block collision
            this.blocks.forEach((block, index) => {
                if (
                    this.position.x + this.size > block.x &&
                    this.position.x - this.size < block.x + block.width &&
                    this.position.y + this.size > block.y &&
                    this.position.y - this.size < block.y + block.height
                ) {
                    this.speed.y = -this.speed.y;
                    block.hitsRemaining--;
                    if (block.hitsRemaining <= 0) {
                        this.blocks.splice(index, 1); // remove block when no hits left
                    }
                }
            });

            // Bottom of screen (lose condition)
            if (this.position.y - this.size > this.game.height) {
                this.game.onGameOver();
            }
        }
    }

    class Block {
        constructor(x, y, width, height, hitsRemaining) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.hitsRemaining = hitsRemaining;
        }

        getColor() {
            switch (this.hitsRemaining) {
                case 3: return "red";
                case 2: return "orange";
                case 1: return "yellow";
                default: return "gray";
            }
        }

        draw(ctx) {
            ctx.fillStyle = this.getColor();
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }

    class InputHandler {
        constructor(paddle) {
            document.addEventListener('keydown', (event) => {
                switch(event.key) {
                    case 'ArrowLeft': paddle.moveLeft(); break;
                    case 'ArrowRight': paddle.moveRight(); break;
                }
            });
            document.addEventListener('keyup', (event) => {
                switch(event.key) {
                    case 'ArrowLeft': if (paddle.speed < 0) paddle.stop(); break;
                    case 'ArrowRight': if (paddle.speed > 0) paddle.stop(); break;
                }
            });
        }
    }

    function generateBlocks(game) {
        const blocks = [];
        const rows = 5;
        const cols = 10;
        const blockWidth = 70 * game.xScale;
        const blockHeight = 20 * game.yScale;
        const hGap = 5 * game.xScale;
        const vGap = 5 * game.yScale;
        const xOffset = 35 * game.xScale;
        const yOffset = 30 * game.yScale;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const hits = Math.floor(Math.random() * 3) + 1;
                blocks.push(new Block(
                    col * (blockWidth + hGap) + xOffset, 
                    row * (blockHeight + vGap) + yOffset, 
                    blockWidth, 
                    blockHeight, 
                    hits
                ));
            }
        }
        return blocks;
    }

    class Game {
        constructor(onGameOverCb) {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.width = this.canvas.width;
            this.height = this.canvas.height;
            this.xScale = this.width / BASE_WIDTH;
            this.yScale = this.height / BASE_HEIGHT;
            this.paddle = new PlayerPaddle(this);
            this.blocks = generateBlocks(this);
            this.ball = new Ball(this, this.paddle, this.blocks);
            new InputHandler(this.paddle);
            this.score = 0;
            this.onGameOverCb = onGameOverCb;
        }

        onGameOver() {
            this.stop();
            if (this.onGameOverCb) {
                this.onGameOverCb(this.score);
            }
        }

        resize() {
            this.width = this.canvas.width;
            this.height = this.canvas.height;
            this.xScale = this.width / BASE_WIDTH;
            this.yScale = this.height / BASE_HEIGHT;
            // Save paddle position as a ratio of canvas width
            let paddleXRatio = (this.paddle.position.x + this.paddle.width / 2) / (this.width || 1);
            this.paddle.reset();
            // Restore paddle center relative to new width
            this.paddle.position.x = this.width * paddleXRatio - this.paddle.width / 2;
            this.ball.reset();
            // Regenerate blocks with new size, but keep count
            this.blocks = generateBlocks(this);
            this.ball.blocks = this.blocks;
        }

        update() {
            this.paddle.update();
            this.ball.update();
        }

        draw() {
            this.ctx.clearRect(0, 0, this.width, this.height);
            this.paddle.draw(this.ctx);
            this.ball.draw(this.ctx);
            this.blocks.forEach(block => block.draw(this.ctx));
            // Draw stats
            this.score = 50 - this.blocks.length;
            this.ctx.fillStyle = "white";
            this.ctx.font = `${20 * this.yScale}px Arial`;
            this.ctx.textAlign = "left";
            this.ctx.fillText(`Score: ${this.score}`, 10, 20 * this.yScale + 5);
            this.ctx.textAlign = "right";
            this.ctx.fillText(`Blocks: ${this.blocks.length}`, this.width - 10, 20 * this.yScale + 5);
        }

        loop = (timestamp) => {
            if (!this.running) return;
            this.update();
            this.draw();

            if (this.blocks.length === 0) {
                this.blocks = generateBlocks(this);
                this.ball.blocks = this.blocks;
            }
            requestAnimationFrame(this.loop);
        };

        start() {
            this.running = true;
            requestAnimationFrame(this.loop);
        }

        stop() {
            this.running = false;
        }
    }

    let game;
    let started = false;

    function showGameOverPage(finalScore) {
        document.getElementById('gameOverScreen').style.display = 'flex';
        document.getElementById('finalScore').innerText = `Your Score: ${finalScore}`;
    }

    function hideGameOverPage() {
        document.getElementById('gameOverScreen').style.display = 'none';
    }

    function startGame() {
        resizeCanvas();
        hideGameOverPage();
        if (!game) game = new Game(showGameOverPage);
        else {
            game.resize();
            game.onGameOverCb = showGameOverPage;
        }
        started = true;
        document.getElementById('startButton').style.display = 'none';
        game.start();
    }

    function restartGame() {
        startGame();
    }

    function resizeCanvasAndGame() {
        resizeCanvas();
        if (game) {
            game.resize();
        }
        if (!started || document.getElementById('gameOverScreen').style.display === "flex") {
            // Draw start page or game over
            const ctx = document.getElementById('gameCanvas').getContext('2d');
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.fillStyle = "white";
            ctx.font = `${Math.floor(ctx.canvas.height/16)}px Arial`;
            ctx.textAlign = "center";
            ctx.fillText("Pong Clone with Blocks", ctx.canvas.width / 2, ctx.canvas.height / 2 - 20);
        }
    }

    window.addEventListener('resize', resizeCanvasAndGame);

    window.addEventListener('load', () => {
        resizeCanvasAndGame();
        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('restartButton').addEventListener('click', () => {
            hideGameOverPage();
            restartGame();
        });
    });
    </script>
</body>
</html>